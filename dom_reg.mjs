import * as l from './lang.mjs'

const G = globalThis

export class HTMLElement extends (G.HTMLElement || Object) {constructor() {reg(new.target), super()}}

const H = HTMLElement

export class HTMLAnchorElement extends (G.HTMLAnchorElement || H) {constructor() {reg(new.target), super()}}
export class HTMLAreaElement extends (G.HTMLAreaElement || H) {constructor() {reg(new.target), super()}}
export class HTMLAudioElement extends (G.HTMLAudioElement || H) {constructor() {reg(new.target), super()}}
export class HTMLBaseElement extends (G.HTMLBaseElement || H) {constructor() {reg(new.target), super()}}
export class HTMLBodyElement extends (G.HTMLBodyElement || H) {constructor() {reg(new.target), super()}}
export class HTMLBRElement extends (G.HTMLBRElement || H) {constructor() {reg(new.target), super()}}
export class HTMLButtonElement extends (G.HTMLButtonElement || H) {constructor() {reg(new.target), super()}}
export class HTMLCanvasElement extends (G.HTMLCanvasElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDataElement extends (G.HTMLDataElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDataListElement extends (G.HTMLDataListElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDetailsElement extends (G.HTMLDetailsElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDialogElement extends (G.HTMLDialogElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDivElement extends (G.HTMLDivElement || H) {constructor() {reg(new.target), super()}}
export class HTMLDListElement extends (G.HTMLDListElement || H) {constructor() {reg(new.target), super()}}
export class HTMLEmbedElement extends (G.HTMLEmbedElement || H) {constructor() {reg(new.target), super()}}
export class HTMLFieldSetElement extends (G.HTMLFieldSetElement || H) {constructor() {reg(new.target), super()}}
export class HTMLFontElement extends (G.HTMLFontElement || H) {constructor() {reg(new.target), super()}}
export class HTMLFormElement extends (G.HTMLFormElement || H) {constructor() {reg(new.target), super()}}
export class HTMLFrameElement extends (G.HTMLFrameElement || H) {constructor() {reg(new.target), super()}}
export class HTMLFrameSetElement extends (G.HTMLFrameSetElement || H) {constructor() {reg(new.target), super()}}
export class HTMLHeadElement extends (G.HTMLHeadElement || H) {constructor() {reg(new.target), super()}}
export class HTMLHeadingElement extends (G.HTMLHeadingElement || H) {constructor() {reg(new.target), super()}}
export class HTMLHRElement extends (G.HTMLHRElement || H) {constructor() {reg(new.target), super()}}
export class HTMLHtmlElement extends (G.HTMLHtmlElement || H) {constructor() {reg(new.target), super()}}
export class HTMLIFrameElement extends (G.HTMLIFrameElement || H) {constructor() {reg(new.target), super()}}
export class HTMLImageElement extends (G.HTMLImageElement || H) {constructor() {reg(new.target), super()}}
export class HTMLInputElement extends (G.HTMLInputElement || H) {constructor() {reg(new.target), super()}}
export class HTMLLabelElement extends (G.HTMLLabelElement || H) {constructor() {reg(new.target), super()}}
export class HTMLLegendElement extends (G.HTMLLegendElement || H) {constructor() {reg(new.target), super()}}
export class HTMLLIElement extends (G.HTMLLIElement || H) {constructor() {reg(new.target), super()}}
export class HTMLLinkElement extends (G.HTMLLinkElement || H) {constructor() {reg(new.target), super()}}
export class HTMLMapElement extends (G.HTMLMapElement || H) {constructor() {reg(new.target), super()}}
export class HTMLMarqueeElement extends (G.HTMLMarqueeElement || H) {constructor() {reg(new.target), super()}}
export class HTMLMenuElement extends (G.HTMLMenuElement || H) {constructor() {reg(new.target), super()}}
export class HTMLMetaElement extends (G.HTMLMetaElement || H) {constructor() {reg(new.target), super()}}
export class HTMLMeterElement extends (G.HTMLMeterElement || H) {constructor() {reg(new.target), super()}}
export class HTMLModElement extends (G.HTMLModElement || H) {constructor() {reg(new.target), super()}}
export class HTMLObjectElement extends (G.HTMLObjectElement || H) {constructor() {reg(new.target), super()}}
export class HTMLOListElement extends (G.HTMLOListElement || H) {constructor() {reg(new.target), super()}}
export class HTMLOptGroupElement extends (G.HTMLOptGroupElement || H) {constructor() {reg(new.target), super()}}
export class HTMLOptionElement extends (G.HTMLOptionElement || H) {constructor() {reg(new.target), super()}}
export class HTMLOutputElement extends (G.HTMLOutputElement || H) {constructor() {reg(new.target), super()}}
export class HTMLParagraphElement extends (G.HTMLParagraphElement || H) {constructor() {reg(new.target), super()}}
export class HTMLParamElement extends (G.HTMLParamElement || H) {constructor() {reg(new.target), super()}}
export class HTMLPictureElement extends (G.HTMLPictureElement || H) {constructor() {reg(new.target), super()}}
export class HTMLPreElement extends (G.HTMLPreElement || H) {constructor() {reg(new.target), super()}}
export class HTMLProgressElement extends (G.HTMLProgressElement || H) {constructor() {reg(new.target), super()}}
export class HTMLQuoteElement extends (G.HTMLQuoteElement || H) {constructor() {reg(new.target), super()}}
export class HTMLScriptElement extends (G.HTMLScriptElement || H) {constructor() {reg(new.target), super()}}
export class HTMLSelectElement extends (G.HTMLSelectElement || H) {constructor() {reg(new.target), super()}}
export class HTMLSlotElement extends (G.HTMLSlotElement || H) {constructor() {reg(new.target), super()}}
export class HTMLSourceElement extends (G.HTMLSourceElement || H) {constructor() {reg(new.target), super()}}
export class HTMLSpanElement extends (G.HTMLSpanElement || H) {constructor() {reg(new.target), super()}}
export class HTMLStyleElement extends (G.HTMLStyleElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableCaptionElement extends (G.HTMLTableCaptionElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableCellElement extends (G.HTMLTableCellElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableColElement extends (G.HTMLTableColElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableElement extends (G.HTMLTableElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableRowElement extends (G.HTMLTableRowElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTableSectionElement extends (G.HTMLTableSectionElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTemplateElement extends (G.HTMLTemplateElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTextAreaElement extends (G.HTMLTextAreaElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTimeElement extends (G.HTMLTimeElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTitleElement extends (G.HTMLTitleElement || H) {constructor() {reg(new.target), super()}}
export class HTMLTrackElement extends (G.HTMLTrackElement || H) {constructor() {reg(new.target), super()}}
export class HTMLUListElement extends (G.HTMLUListElement || H) {constructor() {reg(new.target), super()}}
export class HTMLVideoElement extends (G.HTMLVideoElement || H) {constructor() {reg(new.target), super()}}

export function reg(cls) {return cer.reg(cls)}
export function regAs(cls, tag) {return cer.regAs(cls, tag)}

export class CustomElementRegistry extends l.Emp {
  constructor(ref) {
    super()
    this.ref = optDefiner(ref)
    this.tagToCls = new Map()
    this.clsToTag = new Map()
    this.baseTags = new Map()
  }

  /* Standard behaviors */

  define(tag, cls, opt) {
    this.redundant(tag, cls)
    this.tagToCls.set(tag, cls)
    this.clsToTag.set(cls, tag)
    if (this.ref) this.ref.define(tag, cls, opt)
  }

  get(key) {return this.tagToCls.get(key)}
  upgrade() {}
  whenDefined() {}

  /* Non-standard behaviors */

  reg(cls) {
    if (!this.hasCls(cls)) {
      this.define(this.clsTagSalted(cls), cls, this.clsOpt(cls))
    }
    return cls
  }

  regAs(cls, tag) {
    if (!this.hasCls(cls)) {
      this.define(tag, cls, this.clsOpt(cls))
    }
    return cls
  }

  hasTag(val) {return this.tagToCls.has(val)}
  tagCls(val) {return this.tagToCls.get(val)}

  hasCls(val) {return this.clsToTag.has(val)}
  clsTag(val) {return this.clsToTag.get(val)}

  // Avoids breakage due to class name collisions.
  clsTagSalted(cls) {
    const base = clsTag(cls)
    let tag = base
    let ind = 0
    while (this.hasTag(tag)) tag = base + `-` + ind++
    return tag
  }

  clsOpt(cls) {
    const tag = this.clsTagBase(cls)
    return tag ? {extends: tag} : undefined
  }

  clsTagBase(cls) {
    // Opt-in override.
    if (l.hasOwn(cls, `tag`)) {
      const val = cls.tag
      if (val) return l.reqStr(val)
    }

    const name = clsNameBase(cls, RE_BASE)
    if (!name) return ``

    if (!this.baseTags.has(name)) {
      const mat = name.match(RE_BASE)
      this.baseTags.set(name, mat ? mat[1].toLowerCase() : ``)
    }

    return this.baseTags.get(name)
  }

  setBase(key, val) {return this.baseTags.set(key, val), this}

  redundant(tag, cls) {
    l.reqStr(tag)
    l.reqCls(cls)

    if (this.hasTag(tag)) {
      throw Error(`redundant registration of ${l.show(tag)}`)
    }
    if (this.hasCls(cls)) {
      throw Error(`redundant registration of ${l.show(cls)}`)
    }
  }

  unsetDefiner() {this.ref = undefined}

  setDefiner(ref) {
    if ((this.ref = optDefiner(ref))) {
      for (const [cls, tag] of this.clsToTag) {
        this.ref.define(tag, cls, this.clsOpt(cls))
      }
    }
  }

  clear() {
    this.tagToCls.clear()
    this.clsToTag.clear()
    return this
  }
}

// Short for "custom element registry". Mostly for internal use.
export const cer = /* @__PURE__ */ new CustomElementRegistry(G.customElements)
  // Unambiguous cases.
  .setBase(`HTMLAnchorElement`, `a`)
  .setBase(`HTMLQuoteElement`, `blockquote`)
  .setBase(`HTMLDListElement`, `dl`)
  .setBase(`HTMLImageElement`, `img`)
  .setBase(`HTMLOListElement`, `ol`)
  .setBase(`HTMLParagraphElement`, `p`)
  .setBase(`HTMLTableCaptionElement`, `caption`)
  .setBase(`HTMLTableRowElement`, `tr`)
  .setBase(`HTMLUListElement`, `ul`)
  // Ambiguous cases.
  .setBase(`HTMLTableColElement`, `col`)       // All: col, colgroup.
  .setBase(`HTMLTableSectionElement`, `tbody`) // All: thead, tbody, tfoot.
  .setBase(`HTMLTableCellElement`, `td`)       // All: th, td.

export function clsTag(cls) {
  const words = toWords(cls.name)
  switch (words.length) {
    case 0: return ``
    case 1: return `a-` + words[0].toLowerCase()
    default: return toKebab(words)
  }
}

function clsNameBase(cls, reg) {
  l.reqReg(reg)

  while (l.isFun(cls)) {
    const {name} = cls
    if (reg.test(name)) return name
    cls = Object.getPrototypeOf(cls)
  }

  return ``
}

const RE_BASE = /^HTML(\w*)Element$/

/*
Simpler and more restrictive compared to the word regexp in `str.mjs`.
Specialized for converting class names to HTML custom element tags, which allow
only lowercase Latin letters, digits, hyphens. Not equivalent to the algorithm
for converting camel to kebab for dataset attrs.
*/
function toWords(str) {
  return (str && str.match(/[A-Za-z0-9]+?(?=[^a-z0-9]|$)/g)) || []
}

function toKebab(words) {return words.join(`-`).toLowerCase()}

function isDefiner(val) {return l.hasMeth(val, `define`)}
function optDefiner(val) {return l.opt(val, isDefiner)}
